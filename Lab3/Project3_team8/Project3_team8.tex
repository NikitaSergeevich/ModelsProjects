\documentclass{article}
\usepackage{times}
\usepackage{fullpage}

\newcommand{\head}{\subsection*}
\setlength{\parindent}{0pt}

\begin{document}

%_______________________________________________________________________________
% Heading section
%_______________________________________________________________________________
\begin{center}
\rule{\textwidth}{1.5pt} \\ \rule[10pt]{\textwidth}{1pt}\\
MSIT-SE-M-01\hfill Models of Software Systems\\[3ex]
{\Large\bf Project 3: Concurrency}\\[3ex]
Innopolis University \hfill {\bf Due: November 18, 2015} \rule{\textwidth}{1pt}
\\\rule[9.5pt]{\textwidth}{1.5pt}
\end{center}

The purpose of this third project is to give you experience in
modeling a realistic system as a state machine using concurrency.
The example that we will use is the (by now) familiar Infusion Pump.
A general description of an Infusion Pump can be found in the
General Project Documents folder on the class blackboard. The key
ideas that we would like you to get out of this project are: (1) the
use of concurrency to manage complexity, separate concerns, model
reality; (2) checking of properties related to concurrency (safety
and liveness); and (3) additional practice in creating appropriately
abstract models.

\bigskip You should carry out this project in your assigned team. Make sure that everyone in the
group contributes to the overall effort. Each team should submit a single write-up of the project,
due at the beginning of class on the project due date. We have posted a template for a group
project write-up under the Latex section of the course web site.

%___________________________________________________________________________________________________
\head{Task 1 (50 points): Modeling with Concurrency}
%___________________________________________________________________________________________________

Model a 2-line infusion pump in FSP, using concurrency to factor the model into parts that
represent different concerns. Possibilities for separation include things like (a) power system (b) an individual line
(c) alarms (d) user interface for setting of the pump (both initially and during operation).

\bigskip

As always, you will need to pick a level of abstraction appropriate for this model, and it is up to
you to figure out what are the significant aspects of the system that should be included in your
model.\\

\textbf{Answer:}\\

\textbf{Level of abstraction}\\

Pump is a life critical object and one of the base conditions of pump work is power supply. That's why it's important to ensure that changing from electricity to battery or vice versa is performed correctly. In our specification, pump can not work from electricity while it is not plugged in. Pump would start work automatically from the battery, if only battery is not fully discharged. According to our specification the caregiver should be notified about low battery charge when pump is turned on. \\
Another life critical actions are running out of medicine and when line become pinched or plugged. Specification has current volume of fluids into each line. Alarm would inform the caregiver in case if medicine ended or when line is pinched or plugged. \\
According to description of pump, speed of medicine delivery can be changed. To resolve this problem we added the rate for our model which control the amount of delivering medicine per one time period. \\
In our model refill action can be performed but it will change amount of medicine to the maximum. The discrete value for refill will take additional action and even with 5 levels of volume for 2 lines, there will be 10 additional actions that will complicate work with the model. That's why we choose this level of abstraction. \\

Regarding to all above, we decided to consider next main properties of a pump: \\
\begin{itemize}
	\item Power state. Pump may be connected or not connected to AC. In the same time, electrical failure may occur.
	\item Independent lines. Two infusion lines inside of the pump works independently and settings should be made for each of them. Each line has its volume with some level of fluids. 
	\item Settings. The main setting in the pump is a rate with which each of the lines works. It is possible that only one line is working at the moment.
	\item Alarms. There are different alarms that shows problems in the pump.
\end{itemize}
Below is a more detailed description of the model divided into this logical parts.\\

\textbf{Power System} \\

First, pump may be turned on turned off using actions $turnOff$ or $turnOn$. The pump knows state of electricity: is it connected or not. To minimize number of actions and make the model more understandable we decided to treat $plugOff$ action like pump is plugged off from the AC or pump stops when the electrical failure in the building happens.
According to our specification, the pump have information about charge of the battery: $EmptyBattery$, $LowBattery$, $FullBattery$. Action $charge$ can be performed for the battery only if pump is pigged to the AC power and is not fully charged. Action $discharge$ (go to the lower level of charge) can be performed only when pump is plugged off the AC. Also action $dischargeBatteryWhilePluggedOff$ can be used to empty battery when pump is working. In every case you can $changeBattery$ into the new one.
If the pump is in the battery mode and battery is empty, pump turns off and may start working only after $plugIn$ and then $charge$ actions are made or the $changeBattery$ action executed.\\

\textbf{Line} \\

Line has amount of fluids ($f$) and rate of dispense ($r$). We decided to use $r$ as variable which can show if dispense occurs in particular line or not. In initial state for every line $r$ = -1 ($LineOff$) f = 10 ($MaxFluids$). r = -1 means that pump is actually switched off, line cannot dispense and user cannot apply settings until $turnOn$ action will be performed. Action $turnOn$ will change $r$ to 0 ($NotSet$). $NotSet$ means that now we can apply $modifySettings$ action to enter the menu and change available settings. In our model we can change only rate of dispense using action $setRate1$ / $setRate2$. After rate is set, dispense starts ($dispense$ action is available). Amount of dispense per time unit depends on selected rate (2 or 1). Important thing to notice is that dispense occurs independently on different lines in terms of time. During the dispense $medicineEnded$ action can become available when amount of fluids left ($f$) is less then must be dispensed during ongoing iteration. For example if amount of fluids left is 1 and rate is 2 then $medicineEnded$ action will be available instead of $dispense$. Action $medicineEnded$ is synchronized will cause alarm sound and error. The same for actions $pinched$ and $plugged$, but the difference this event can occur at any time during the dispense. Our assumption here is line can become pinched or plugged only during the dispense and lines are not plugged or pinched initially. In case of ended medicine action $dispense$ will be available after performing $refillAfterError$ action. Also $refill$ action is available during the ordinary dispense in order to set amount of medicine (f) to maximum value before it ends. Action $stopDispense$ is available during the dispense. Action $emergencyDischarge$ is synchronized with BATTERY process and switch off the pump (r = $LineOff$). However if discharging of battery doesnâ€™t lead to emergency, in the situation when pump is off $emergencyDischarge$ is not available. It happens when pump worked from battery and battery become discharged fully which prevents to emergency. Also action $emergencyPlugOff$ happens when pump worked from electricity and user of pump(nurse) tried to plug off the pump when the battery is discharged which also leads to emergency. \\

\textbf{Alarms} \\

In our specification there are four types of alarm which are related to each line: 
1. when the line is pinched.\\
2. when the line is plugged.\\
3. when medicine in the line is ended and alarm notifies that the medicine bag should be refilled.\\
4. when backup battery failure happened: two possible variants - pump is plugged off when battery is empty or battery discharge from low battery to empty battery. (If electrical failure would happen we assumed that pump would automatically switch to the battery). Errors 1-3 are connected with lines as a result pump can identify error on particular line. We decided, that it would be convenient for nurse to identify different types of alarms and realize in which line has issues, in order fix problem quickly. Also, errors 1-3 are connected with power mode. When pump is turned off 1-3 alarms would also turned off. We assumed that when pump would be turned on, alarms will occur again automatically. If backup battery failure happen, backup alarm would identify this failure. We assumed that backup alarm works even if there are no power source in the pump.
All alarms can be muted, in order when nurse saw the problem and don't want to be disturbed by alarm. And all alarms have action alarm, which would happen until the error will not be fixed.\\

\textbf{User interface} \\

The only setting that is shown in our model is a rate setting. Rate for each line has to be set independently, so a line can not start dispensing medicine before the rate will be set. Every dispense takes amount of medicine that is set in the current rate of this line. The behaviour is described previously in context of line.




%___________________________________________________________________________________________________
\head{Task 2 (32 points): Stating and Checking Properties}
%___________________________________________________________________________________________________

Once you have your pump specified, consider the following properties. For each say (a) whether the property
is a safety or liveness property,  (b) whether your model allows you to check this property, and if
so, (c) whether it is true or not, and what features of FSP and LTSA allowed you to check the
property. It would be particularly helpful if you include in your write-up the specific checks that you performed -- which should also appear in your FSP file. (Note: not all of these properties have to be true of your pump, depending on how you interpret the requirements for an infusion pump.)

\begin{enumerate}
    \item The pump cannot start pumping without the operator first confirming the settings on the pump.
    
    \textbf{Answer:}
    \begin{enumerate}
    \item It is a safety property, because it asserts that nothing bad happens during execution. In this case, that it is
    impossible to start the pump without confirming the settings.
    \item  Our model allows to check the property. As it was mentioned in our model description, we have modelled only one
    type of settings - setting a rate for a concrete infusion line. Therefore, \verb|dispense| action happens only after
    \verb|setRate[i]| action.
    \item Yes, it is true. Here is the property and LTSA output.
	\begin{verbatim}
	fluent SETTINGS_ARE_SET[i:RangeLine] = 
	<line[i].setRate[j:MinRate..MaxRate], {turnOff, emergencyPlugOff, emergencyDischarge}>
	assert DISPENSE_ONLY_AFTER_SETTINGS = 
	forall[i:RangeLine] [](line[i].dispense -> SETTINGS_ARE_SET[i])
	_______________________________________________
	...
	Depth 27 -- States: 156103 Transitions: 1379653 Memory used: 292890K
	No deadlocks/errors
	Analysed in: 473ms
	\end{verbatim}    
    \end{enumerate}
    
    \item Electrical power can fail at any time.\\
    \textbf{Answer:}
    \begin{enumerate}
    \item It is a liveness property, because it describes that something bad will eventually happen.
    \item Our model allows to check this property. As it was mentioned in our model description, our pump model doesn't make
    difference between cases when pump was plugged off from AC or an electrical failure happened.
    \item Yes, it is true. We can show, that electrical failure (\verb|plugOff| action) can appear infinitely often.
    \begin{verbatim}
    assert ELECTRICAL_FAILURE_AT_ANY_TIME = []<> plugOff
    _________________________________________
    -- States: 390726 Transitions: 4734710 Memory used: 200917K
    No LTL Property violations detected.
    LTL Property Check in: 2064ms
    \end{verbatim}
    \end{enumerate}
     

    \item If the backup battery power fails, pumping will not occur on any line.\\
    \textbf{Answer:}
    \begin{enumerate}
    \item It is safety property. According to our specification pump can dispense fluids if it works from power
    socket (electricity) or battery in case if battery is not empty. Another words, nothing wrong (pumping on any line) will
    not occur in case backup battery power fails.
 
    \item Our model allows to check this property. According to our assumption, backup battery fail is represented by fluent
    $DISCHARGED$ and can occur in two cases:\\
    1. If pump works from electricity with empty battery and electricity fails by $emergencyPlugOff$. \\
    2. If pump works from battery and battery become empty during pumping $emergencyDischarge$. \\
    We can fix this issue and continue dispense by using $chargeBattery$ or $plugIn$ action.\\
    Property NODISPENSE asserts that $dispense$ action is never available during battery fail.
    \begin{verbatim}
    fluent DISCHARGED = <{emergencyPlugOff, emergencyDischarge}, {changeBattery, plugIn}>
    assert NODISPENSE = [](DISCHARGED -> !line[i:RangeLine].dispense)
    \end{verbatim}
    
    \item  Yes, it is true. NODISPENSE assert is not violated in our model. LTSA output:
    \begin{verbatim}
    Depth 21 -- States: 80000 Transitions: 673835 Memory used: 58561K
    Depth 23 -- States: 81492 Transitions: 682019 Memory used: 59618K
    No deadlocks/errors
    Analysed in: 414ms
    \end{verbatim} 
    \end{enumerate}    
    
    \item It is always possible to resume pumping after a failure.\\
    \textbf{Answer:}
    \begin{enumerate}
    \item It is liveness property. According to our specification 4 type of known failures can occur and interrupt
    pumping.\\
    There are: 1.Backup battery fail (described previously) 2.Plugged Line 3.Pinched Line 4.Medicine ended. After any
    failure user can perform set of actions to resume dispense of medicine. \\
 
    \item Our model allows to check this property. Failures are represented by fluent: 1.$DISCHARGED$ 2.$PLUGGED$ 
    3.$PINCHED$ 4.$MEDICINE\_ENDED$ and we have assert $RESUMEDISPENCE$ which checks that after any failure $dispence$ action
    will eventually happen. Any failure can be fixed by performing action described in the fluent.\\
    \begin{verbatim}
    fluent DISCHARGED = <{emergencyPlugOff, emergencyDischarge}, {changeBattery, plugIn}>
    fluent MEDICINE_ENDED[i:RangeLine] = <line[i].medicineEnded, line[i].refillAfterError>
    fluent PINCHED[i:RangeLine] = <line[i].pinched, line[i].unpinched>
    fluent PLUGGED[i:RangeLine] = <line[i].plugged, line[i].unplugged>
    assert RESUMEDISPENCE = forall[i:RangeLine][](MEDICINE_ENDED[i] -> line[i].medicineEnded)
    \end{verbatim}
    
    \item Yes it is true. $RESUMEDISPENCE$ assert is not violated in our model. LTSA checker output:
    \begin{verbatim}
    -- States: 370000 Transitions: 4297076 Memory used: 42270K
    -- States: 380000 Transitions: 4405020 Memory used: 47613K
    -- States: 390000 Transitions: 4509834 Memory used: 37128K
    -- States: 390726 Transitions: 4517989 Memory used: 49377K
    No LTL Property violations detected.
    LTL Property Check in: 4437ms
    \end{verbatim} 
    \end{enumerate}    
    
    \item An alarm will sound on any line failure (blockage, pinching, empty fluid, or whatever failures you model). \\
    \textbf{Answer:}
    \begin{enumerate}
    	\item It's liveness property. Here we are checking for possible failures of the line - thus, something bad may
    	happens.
		\item 
		\item 
		\begin{verbatim}
		assert FAILURE_ALARM = forall[i:RangeLine] [] (MEDICINE_ENDED[i] && X line[i].medicineAlarm || 
		PINCHED[i] && X line[i].medicineAlarm || 
		PLUGGED[i] -> <> ine[i].medicineAlarm)
		\end{verbatim}
	\end{enumerate}
	
    \item In the absence of errors the pump will continue to pump until the treatment is finished.\\
    \textbf{Answer:} 
    \begin{enumerate}
    	\item It is a safety property, because it asserts that nothing bad happens during execution.
    	\item Our model allows to check this from the begin of the dispense of the medicine until the medicine ended 
    	(we assume that the full medicine bag is a standard treatment dose. Therefore, if $medicineEnded$ action happened, we
    	can say that treatment ended).
    	\item Yes, it is true. Here is the assert and LTSA output of the check.
    	\begin{verbatim}
    	assert PUMPING_MEDICINE = forall[i:RangeLine] []((!DISCHARGED && 
    	!PINCHED[i] && !PLUGGED[i] -> <>line[i].dispense) U MEDICINE_ENDED[i])
    	
    	Composition:
    	LTL Property Check...
    	-- States: 10000 Transitions: 90966 Memory used: 72307K
    	.........
    	-- States: 1337568 Transitions: 30886156 Memory used: 214135K
    	No LTL Property violations detected.
    	LTL Property Check in: 18319ms
\end{verbatim}
	\end{enumerate}
    \item The system never deadlocks.\\
    \textbf{Answer:}
    \begin{verbatim}
    Composition:
    PUMP = POWERSUPPLY || line.1:LINE || line.2:LINE || 
    line.1:ALARMMEDICINE || line.2:ALARMMEDICINE ||
    line.1:ALARMPINCHED || line.2:ALARMPINCHED ||
    line.1:ALARMPLUGGED || line.2:ALARMPLUGGED || 
    BACKUPALARM || NODISPENSE
    State Space:
    11 * 91 * 91 * 4 * 4 * 4 * 4 * 4 * 4 * 2 * 2 = 2 ** 32
    Composing...
    Depth 27155 -- States: 10000 Transitions: 85166 Memory used: 57055K
    Depth 36738 -- States: 20000 Transitions: 161710 Memory used: 51790K
    Depth 45841 -- States: 30000 Transitions: 239872 Memory used: 66500K
    Depth 47770 -- States: 40000 Transitions: 313351 Memory used: 56950K
    Depth 40947 -- States: 50000 Transitions: 387912 Memory used: 70896K
    Depth 28055 -- States: 60000 Transitions: 474745 Memory used: 85809K
    Depth 14217 -- States: 70000 Transitions: 562525 Memory used: 77421K
    Depth 1646 -- States: 80000 Transitions: 664961 Memory used: 71068K
    -- States: 81492 Transitions: 682019 Memory used: 95744K
    Composed in 819ms
    \end{verbatim}
    As we can see system is not in a deadlock any time.
    
    \item Two other properties of your choosing.
    
    \begin{itemize}
    \item The main action, dispense, may be made infinitely often (there is no irreversible problems after which it is
    impossible to make a dispense)
    
    \textbf{Answer:}
    \begin{enumerate}
    	\item It is a safety property, because it asserts that nothing bad happens during execution. In this case, that it is
    	impossible to get into loop from which it is impossible to make a dispense.
    	\item Our model allows to check the property. 
    	\item Yes, it is true. Here is the property and LTSA output.
    	\begin{verbatim}    	
    	assert INFINITE_DISPENSE = []<> line[i:RangeLine].dispense
    	 \end{verbatim}
    	 
    	 \item There is more specific version: if there is necessary amount of medicine, dispense, may be made infinitely
    	 often (there is no irreversible problems)
    	 
    	 \begin{verbatim}
    	fluent ENOUGH_MEDICINE[i:RangeLine] =
    	<{line[i].refillAfterError, line[i].refill}, line[i].medicineEnded>
    	assert CONTINUE_DISPENSING =
    	forall[i:RangeLine] [](ENOUGH_MEDICINE[i] -> [] <>line[i].dispense)
    	\end{verbatim}
    	
    	\item Additional check that we used in our model: battery can not charge if the pump is not connected to AC
    	
    	 \begin{verbatim}
    	fluent PUMP_CONNECTED_TO_AC =
    	<plugIn, {plugOff, plugOffToEmptyBattery}>
    	assert CHARGE_ONLY_FROM_BATTERY  = 
    	(charge -> ! PUMP_CONNECTED_TO_AC )
    	\end{verbatim}
    	\end{enumerate}
    	\end{itemize}
    	    
\end{enumerate}

Now come up with two more properties that are not in the above list, and check them.
%___________________________________________________________________________________________________
\head{Task 3 (18 points): Reflection}
%___________________________________________________________________________________________________

 You have now seen three notations for specifying systems and their properties: Pre-post conditions,
 Z (Z/Eves and Fuzz), and FSP (LTSA).  In this part of the report we would like you to reflect on that experience.
 For each of these notations write a paragraph or two explaining:
\begin{enumerate}
 \item What are the strengths of this notation and its tools?  Under what situations would you
recommend its use? Why?
 \item What are the weaknesses of this notation and its tools. Under what
situations would you not not recommend its use? Why?
 \item With respect to this notation, what is
the single most-important future development that would be needed to make it more generally useful
to practitioners?

\end{enumerate}

\end{document}
