\documentclass{article}
\usepackage{times}
\usepackage{fullpage}

\newcommand{\head}{\subsection*}
\setlength{\parindent}{0pt}

\begin{document}

%_______________________________________________________________________________
% Heading section
%_______________________________________________________________________________
\begin{center}
\rule{\textwidth}{1.5pt} \\ \rule[10pt]{\textwidth}{1pt}\\
MSIT-SE-M-01\hfill Models of Software Systems\\[3ex]
{\Large\bf Project 3: Concurrency}\\[3ex]
Innopolis University \hfill {\bf Due: November 18, 2015} \rule{\textwidth}{1pt}
\\\rule[9.5pt]{\textwidth}{1.5pt}
\end{center}

The purpose of this third project is to give you experience in
modeling a realistic system as a state machine using concurrency.
The example that we will use is the (by now) familiar Infusion Pump.
A general description of an Infusion Pump can be found in the
General Project Documents folder on the class blackboard. The key
ideas that we would like you to get out of this project are: (1) the
use of concurrency to manage complexity, separate concerns, model
reality; (2) checking of properties related to concurrency (safety
and liveness); and (3) additional practice in creating appropriately
abstract models.

\bigskip You should carry out this project in your assigned team. Make sure that everyone in the
group contributes to the overall effort. Each team should submit a single write-up of the project,
due at the beginning of class on the project due date. We have posted a template for a group
project write-up under the Latex section of the course web site.

%___________________________________________________________________________________________________
\head{Task 1 (50 points): Modeling with Concurrency}
%___________________________________________________________________________________________________

Model a 2-line infusion pump in FSP, using concurrency to factor the model into parts that
represent different concerns. Possibilities for separation include things like (a) power system (b) an individual line
(c) alarms (d) user interface for setting of the pump (both initially and during operation).

\bigskip

As always, you will need to pick a level of abstraction appropriate for this model, and it is up to
you to figure out what are the significant aspects of the system that should be included in your
model.

%___________________________________________________________________________________________________
\head{Task 2 (32 points): Stating and Checking Properties}
%___________________________________________________________________________________________________

Once you have your pump specified, consider the following properties. For each say (a) whether the property
is a safety or liveness property,  (b) whether your model allows you to check this property, and if
so, (c) whether it is true or not, and what features of FSP and LTSA allowed you to check the
property. It would be particularly helpful if you include in your write-up the specific checks that you performed -- which should also appear in your FSP file. (Note: not all of these properties have to be true of your pump, depending on how you interpret the requirements for an infusion pump.)

\begin{enumerate}
    \item The pump cannot start pumping without the operator first confirming the settings on the pump.
    
    \textbf{Answer:}
    \begin{enumerate}
    \item It is a safety property, because it asserts that nothing bad happens during execution. In this case, that it is impossible to start the pump without confirming the settings.
    \item  Our model allows to check the property. As it was mentioned in our model description, we have modelled only one type of settings - setting a rate for a concrete infusion line. Therefore, \verb|dispense| action happens only after \verb|setRate[i]| action.
    \item Yes, it is true. Here is the property and LTSA output.
	\begin{verbatim}
fluent SETTINGS_ARE_SET[i:RangeLine] =
<line[i].setRate[j:MinRate..MaxRate], {turnOff, plugOffToEmptyBattery}>
assert DISPENSE_ONLY_AFTER_SETTINGS =
forall[i:RangeLine] [](line[i].dispense -> SETTINGS_ARE_SET[i])

_______________________________________________
...
Depth 27 -- States: 156103 Transitions: 1379653 Memory used: 292890K
No deadlocks/errors
Analysed in: 473ms
	\end{verbatim}    
    \end{enumerate}
    
    \item Electrical power can fail at any time.\\
    \textbf{Answer:}
    \begin{enumerate}
    	\item It is a liveness property, because it describes that something bad will eventually happen.
    	\item Our model allows to check this property. As it was mentioned in our model description, our pump model doesn't make differense between cases when pump was plugged off from AC or an electrical failure happened.
    	\item Yes, it is true. We can show, that electrical failure (\verb|plugOff| action) can appear infinitely often.
    	
    	\begin{verbatim}
    	assert ELECTRICAL_FAILURE_AT_ANY_TIME = []<> plugOff
    	_________________________________________
    	-- States: 390726 Transitions: 4734710 Memory used: 200917K
    	No LTL Property violations detected.
    	LTL Property Check in: 2064ms
    	\end{verbatim}
    \end{enumerate}
     

    \item If the backup battery power fails, pumping will not occur on any line.\\
    \textbf{Answer:}
    \begin{enumerate}
    \item It is safety property. According to our specification pump can dispense fluids if it works from power
    socket (electricity) or battery in case if battery is not empty. Another words, nothing wrong (pumping on any line) will
    not occur in case backup battery power fails.
 
    \item Our model allows to check this property. According to our assumption, backup battery fail is represented by fluent
    $DISCHARGED$ and can occur in two cases:\\
    1. If pump works from electricity with empty battery and electricity fails by \textbf{Check it:} $plugOffToEmptyBattery$
    $plug\_off$ action.\\
    2. If pump works from battery and battery become empty during pumping (by double $discharge$ action).
    We can fix this issue and continue dispense by using $chargeBattery$ or $plugIn$ action.\\
    \textbf{Check it:} Assert or Property NODISPENSE tells us that $dispense$ action is never available during battery fail.
    \begin{verbatim}
    fluent DISCHARGED = <plugOffToEmptyBattery, {chargeBattery, plugIn}>
    assert NODISPENSE = [](DISCHARGED -> !line[i:RangeLine].dispense)
    \end{verbatim}
    
    \item NODISPENSE property is not violated in our model. LTSA output.
    \begin{verbatim}
    Violated.
    \end{verbatim} 
    \end{enumerate}    
    
    
    \item It is always possible to resume pumping after a failure.
        \item It is always possible to resume pumping after a failure.\\
    \textbf{Answer:}
    \begin{enumerate}
    \item It is liveness property. According to our specification 4 type of known failures can occur and interrupt
    pumping.
    There are: 1.Backup battery fail (described previously) 2.Plugged Line 3.Pinched Line 4.Medicine ended. After any
    failure user can perform set of actions to resume dispense of medicine.
 
    \item Our model allows to check this property. Failures are represented by fluent: 1.$DISCHARGED$ 2.$PLUGGED$ 
    3.$PINCHED$ 4.$MEDICINE\_ENDED$ and we have assert $RESUMEDISPENCE$ which checks that after any failure $dispence$ action
    will eventually happen. Any failure can be fixed by performing action described in the fluent.\\
    \begin{verbatim}
    fluent DISCHARGED = <plugOffToEmptyBattery, {chargeBattery, plugIn}>
    fluent MEDICINE_ENDED[i:RangeLine] = <line[i].medicineEnded, line[i].refillAfterError>
    fluent PINCHED[i:RangeLine] = <line[i].pinched, line[i].unpinched>
    fluent PLUGGED[i:RangeLine] = <line[i].plugged, line[i].unplugged>
    assert RESUMEDISPENCE = [](exists[i:RangeLine](MEDICINE_ENDED[i] || PINCHED[i] || PLUGGED[i] -> <>line[i].dispence))
    \end{verbatim}
    
    \item $RESUMEDISPENCE$ property is not violated in our model. LTSA checker output:
    \begin{verbatim}
    -- States: 370000 Transitions: 4297076 Memory used: 42270K
    -- States: 380000 Transitions: 4405020 Memory used: 47613K
    -- States: 390000 Transitions: 4509834 Memory used: 37128K
    -- States: 390726 Transitions: 4517989 Memory used: 49377K
    No LTL Property violations detected.
    LTL Property Check in: 4437ms
    \end{verbatim} 
    \end{enumerate}    
    
    
    
    \item An alarm will sound on any line failure (blockage, pinching, empty fluid, or
whatever failures you model).\\
    \textbf{Answer:}
    \begin{enumerate}
    	\item It's liveness property. Here we are checking for possible failures of the line - thus, something bad may happens.
		\item Our model allows to check this property during the LINE process at all.
		\item Yes, we check this using "property" in LTSA. Here is the code and log of composing model:
\begin{verbatim}
property SAFE_DISPENSE
=(medicineEnded -> refillAfterError -> SAFE_DISPENSE).

Composing...
Depth 19093 -- States: 10000 Transitions: 68357 Memory used: 24181K
..........................................................
-- States: 162500 Transitions: 1373754 Memory used: 145534K
Composed in 1528ms
State Space:
\end{verbatim}
	\end{enumerate}
    \item In the absence of errors the pump will continue to pump until the
treatment is finished.\\
    \textbf{Answer:} 
    \begin{enumerate}
    	\item It is a safety property, because it asserts that nothing bad happens during execution.
    	\item Our model allows to check this from the begin of the dispense of the medicine until the medicine ended 
    	(we assume that the full medicine bag is a standard treatment dose. Therefore, if $medicineEnded$ action happened, we can say that treatment ended).
    	\item Yes, it is true. Here is the assert and LTSA output of the check.
\begin{verbatim}
assert PUMPING_MEDICINE = [](forall[i:RangeLine] 
((!DISCHARGED && !PINCHED[i] && !PLUGGED[i] 
-> <>line[i].dispense) U MEDICINE_ENDED[i]))

Composition:
LTL Property Check...
-- States: 10000 Transitions: 90966 Memory used: 72307K
.........
-- States: 1337568 Transitions: 30886156 Memory used: 214135K
No LTL Property violations detected.
LTL Property Check in: 18319ms
\end{verbatim}
	\end{enumerate}
    \item The system never deadlocks.\\
    \textbf{Answer:}
    \begin{verbatim}
    Composition:
EVERYTHING = PUMP || line.1:LINE || line.2:LINE || line.1:ALARM 
|| line.2:ALARM || BATTERY || line.1:SAFE_DISPENSE || line.2:SAFE_DISPENSE
State Space:
 4 * 102 * 102 * 6 * 6 * 3 * 2 * 2 = 2 ** 26
Composing...
Depth 37344 -- States: 10000 Transitions: 91019 Memory used: 69586K
Depth 58240 -- States: 20000 Transitions: 174654 Memory used: 84214K
Depth 64991 -- States: 30000 Transitions: 256613 Memory used: 98240K
Depth 68622 -- States: 40000 Transitions: 339361 Memory used: 112318K
Depth 58253 -- States: 50000 Transitions: 423537 Memory used: 88841K
Depth 46493 -- States: 60000 Transitions: 506861 Memory used: 102857K
Depth 34069 -- States: 70000 Transitions: 589260 Memory used: 116380K
Depth 21875 -- States: 80000 Transitions: 674665 Memory used: 130385K
Depth 9779 -- States: 90000 Transitions: 769373 Memory used: 106446K
-- States: 97998 Transitions: 843738 Memory used: 152722K
Composed in 974ms
    \end{verbatim}
    As we can see system is not in a deadlock anytime.
    
    \item Two other properties of your choosing.
    
    \begin{itemize}
    \item The main action, dispense, may be made infinitely often (there is no irreversible problems after which it is impossible to make a dispense)
    
    \textbf{Answer:}
    \begin{enumerate}
    	\item It is a safety property, because it asserts that nothing bad happens during execution. In this case, that it is impossible to get into loop from which it is impossible to make a dispense.
    	\item  Our model allows to check the property. 
    	\item Yes, it is true. Here is the property and LTSA output.
    	\begin{verbatim}
    	
    	assert INFINITE_DISPENSE = []<> line[i:RangeLine].dispense
    	 \end{verbatim}
    	
    \item	There is more specific version: if there is necessary amount of medicine, dispense, may be made infinitely often (there is no irreversible problems)
    
    \begin{verbatim}
    	fluent ENOUGH_MEDICINE[i:RangeLine] =
    	<{line[i].refillAfterError, line[i].refill}, line[i].medicineEnded>
    	assert CONTINUE_DISPENSING =
    	forall[i:RangeLine] [](ENOUGH_MEDICINE[i] -> [] <>line[i].dispense)
    	
    	\end{verbatim}
    	
    	\item Additional check that we used in our model: battery can not charge if the pump is not connected to AC
    	
    	 \begin{verbatim}
    	fluent PUMP_CONNECTED_TO_AC =
    	<plugIn, {plugOff, plugOffToEmptyBattery}>
    	assert CHARGE_ONLY_FROM_BATTERY  = 
    	(charge -> ! PUMP_CONNECTED_TO_AC )
    	
    \end{verbatim}
    \end{enumerate}
    \end{itemize}
     
    
    
    
\end{enumerate}

Now come up with two more properties that are not in the above list, and check them.
%___________________________________________________________________________________________________
\head{Task 3 (18 points): Reflection}
%___________________________________________________________________________________________________

 You have now seen three notations for specifying systems and their properties: Pre-post conditions,
 Z (Z/Eves and Fuzz), and FSP (LTSA).  In this part of the report we would like you to reflect on that experience.
 For each of these notations write a paragraph or two explaining:
\begin{enumerate}
 \item What are the strengths of this notation and its tools?  Under what situations would you recommend its use? Why?
 \item What are the weaknesses of this notation and its tools. Under what
situations would you not not recommend its use? Why?
 \item With respect to this notation, what is
the single most-important future development that would be needed to make it more generally useful
to practitioners?
\end{enumerate}


\begin{enumerate}
\item \textbf{Pre-post conditions}

\textbf{Strengths}

\begin{enumerate}
\item Visible dividing between pre- and postconditions, we can specify the input and output of each action in clear way.
\item Predicate Logic knowledge gives a lot of operations to properly specify different logic of PreAndPost conditions.
\item Simplicity because of using well-know predicate logic and ability to understand whether particular action might or not might be made because of preconditions
\item Some languages like Eiffel support operational contracts with similar logic because it is easier to find errors using contracts. Therefore, knowledge of pre- and postconditions technique may make the Eiffel lessons more understandable and pleasant for Innopolis students.
\item Ability to get result from an action or to get exception may be quite useful in many cases.
\end{enumerate}


\textbf{Weaknesses}

\begin{enumerate}
\item There are no any ways to model concurrency in these models. 
\item We have made a little research and have not found any appropriate tools for checking correctness of Pre and Post conditions models in general way.
\item With growing of variables number it is harder to write new actions because you have to explicitly say new state for every available variable.
\end{enumerate}
\item \textbf{Z}

\textbf{Strengths}
\begin{enumerate}
\item Tools like z-community and fuzz has type checkers which help to identify syntax errors.
\item We can describe explicitly every needed state of the model in terms of pre- and postconditions using schemas, every schema is described by variables.
\item Important that we can state precondition for every transition which explicitly define state of particular schema in which we can apply this action. Also we can define postcondition to define state of shema after transition, what is relative to action’s return value.
\item Schema invariants show conditions which are always true for the model, it gives ability to not rewrite some common conditions into all states.
\item Differences between read-only and write modes ($\Theta$ and $\Xi$) helps to reduce number of occasional errors. 
\item Predicate Logic knowledge gives a lot of operations to properly specify different logic of actions.
\item Such operations like Promotion or Framing Schema simplifies the final model.
\item Schemas help to reuse abstractions and shared components
\end{enumerate}

\textbf{Weaknesses}
\begin{enumerate}
\item Tools like z-community and fuzz can’t check if some states of the system are unreachable, we have no opportunity to somehow move from state to state using defined state transitions to check some particular behaviour. 
\item It is quite hard to create some sequence of actions so that one should go after another. There are some tricks for it (like incrementing some counter and checking it in preconditions), but it is not a common option.
\item Z notation is not supposed to show work of concurrent processes.
\end{enumerate}

\item \textbf{FSP and LTSA}

\textbf{Strengths}
\begin{enumerate}
\item Ability to model concurrent processes.
\item Ability to check desired properties of the system, such as safety and liveness properties
\item Ability to check properties using Temporal Propositions and built-in syntax for creating fluents needed to use the logic.
\item Ability to see the possible sequences of actions in the LTSA tool
\item Visualisation of simple state machines, good for educational purposes.

\end{enumerate}
\textbf{Weaknesses}
\begin{enumerate}
\item Only actions are shown in the system, we do not know in what state we are now using the animator.
\item We couldn’t match LTSA model with real time, it is a problem of state machines. 
\item 	FSP doesn’t allow to make probabilistic actions, that some action will happen with some probability. We only may show priorities of actions for checks.
\item 	Parameters inside the processes result in fast state space growing, so several processes (3-4) having several parameters (4-5) united with parallel composition lead to impossibility of model checking because of stack overflow.
\item 	LTSA tool doesn’t allow to visualise big graphs (with many states).
\item 	LTSA tool interface is not very convenient to use. For example, in animation mode it doesn’t show actions in table layout and makes long list of actions. In addition, some important hotkeys such as “Ctrl+Z” do not work.
\item 	Using fluent propositions we can not use sequence of several actions as an initiating or terminating actions. For example, show that if system in a $Full$ state, after two $discharge$ actions system will go into $Empty$ state and if system in a $Medium$ state, it will go into $Empty$ state after the first $discharge$ action.
	
\end{enumerate}

LTSA is the best choice to show concurrent processes and check their properties. Checking the order of operations is quite convenient. However, processes should not be very complicated.

\end{enumerate}
\end{document}
