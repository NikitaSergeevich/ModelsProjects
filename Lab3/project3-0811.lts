const NumberOfLines = 2
range LinesRange = 1..NumberOfLines


// Assumption 1: 20% of battery is enough for 4 hours of working 
// (according to requirements from 
// "Generic Infusion Pump Hazard Analysis and Safety Requirements")

const EmptyBattery = 0 	// Battery is empty
const LowBattery = 1 	// Pump uses battery with charge is enough for less than 4 hours
const FullBattery = 2 	// Pump uses battery with charge is enough for more than 4 hours

range BatteryState =  EmptyBattery..FullBattery

const Electricity = 0 	// Pump uses AC power
const Battery = 1 	// Battery mode
range PowerMode = Electricity .. Battery

// on/off
const Off = 0
const On = 1
range OnOff = Off..On

//Assumption 2. When we change the battery, the battery is fully charged.

POWERSUPPLY = PUMPOFF[Battery][FullBattery],  //initial state

PUMPOFF[p:PowerMode][b:BatteryState] = 

// Change power mode
(when (p == Electricity || b > 0) turnOn -> PUMPON[p][b]
|when (p == Electricity) plugOff -> PUMPOFF[Battery][b]
|when (p == Battery) plugIn -> PUMPOFF[Electricity][b]

//EmptyBattery
|when (p == Electricity && b == EmptyBattery) charge ->  PUMPOFF[p][LowBattery]
|when (b == EmptyBattery) changeBattery ->  PUMPOFF[p][FullBattery]

//LowBattery
|when (p == Electricity && b == LowBattery) charge -> PUMPOFF[p][LowBattery]
|when (p == Battery && b == LowBattery) dischargeBattery -> PUMPOFF[p][EmptyBattery]
|when (b == LowBattery) changeBattery ->  PUMPOFF[p][FullBattery]

//FullBattery
|when (p == Electricity && b == FullBattery) charge ->  PUMPOFF[p][FullBattery]
|when (p == Battery && b == FullBattery) dischargeBattery ->  PUMPOFF[p][LowBattery]
|when (b == FullBattery) changeBattery ->  PUMPOFF[p][FullBattery]
),

PUMPON[p:PowerMode][b:BatteryState] = (

// Change power mode.

//Action leads to electrical failure 
when (p == Electricity && b == EmptyBattery) emergencyTurnOff -> PUMPOFF[p][b]

|when (p == Electricity && b != EmptyBattery) plugOff -> PUMPON[Battery][b]
|when (p == Battery) plugIn-> PUMPON[Electricity][b]

// OnOff. Different actions in order to make shared actions
|turnOff -> PUMPOFF[p][b]

// EmptyBattery
|when (p == Electricity && b == EmptyBattery) charge ->  PUMPON[p][LowBattery]
|when (b == EmptyBattery) changeBattery ->  PUMPON[p][FullBattery]

// LowBattery

//Action leads to electrical failure 
|when (p == Battery && b == LowBattery) emergencyTurnOff  -> PUMPOFF[p][EmptyBattery]

|when (b == LowBattery) changeBattery ->  PUMPON[p][FullBattery]
|when (p == Electricity && b == LowBattery) charge -> PUMPON[p][LowBattery]

// FullBattery
|when (p == Electricity && b == FullBattery) charge ->  PUMPON[p][FullBattery]
|when (p != Electricity && b == FullBattery) dischargeBattery ->  PUMPON[p][LowBattery]
|when (b == FullBattery) changeBattery ->  PUMPON[p][FullBattery]
)
. 

ALARMMEDICINE = (turnOn -> ALARMMEDICINEOFF),

ALARMMEDICINEOFF = (errorMedicine -> ALARMMEDICINEON
|turnOff -> ALARMMEDICINE
|emergencyTurnOff -> ALARMMEDICINE
 ),
 
ALARMMEDICINEON = (
medicineAlarm -> ALARMMEDICINEON
|medicineErrorFixed -> ALARMMEDICINEOFF
|muteMedicineAlarm -> ALARMMEDICINEMUTED
|turnOff -> ALARMMEDICINE
|emergencyTurnOff -> ALARMMEDICINE),

ALARMMEDICINEMUTED = (
medicineErrorFixed -> ALARMMEDICINEOFF
|turnOff -> ALARMMEDICINE
|emergencyTurnOff -> ALARMMEDICINE).

ALARMPINCHED = (turnOn -> ALARMPINCHEDOFF),

ALARMPINCHEDOFF = (errorPinched -> ALARMPINCHEDON
|turnOff -> ALARMPINCHED
|emergencyTurnOff -> ALARMPINCHED),

ALARMPINCHEDON = (
pinchedAlarm -> ALARMPINCHEDON
|mutePinchedAlarm -> ALARMPINCHEDMUTED
|reduceErrorPinched -> ALARMPINCHEDOFF
|turnOff -> ALARMPINCHED
|emergencyTurnOff -> ALARMPINCHED),

ALARMPINCHEDMUTED = (
reduceErrorPinched -> ALARMPINCHEDOFF
|turnOff -> ALARMPINCHED
|emergencyTurnOff -> ALARMPINCHED).

ALARMPLUGGED = (turnOn -> ALARMPLUGGEDOFF),

ALARMPLUGGEDOFF = (errorPlugged -> ALARMPLUGGEDON
|turnOff -> ALARMPLUGGED
|emergencyTurnOff -> ALARMPLUGGED),

ALARMPLUGGEDON = (
pluggedAlarm -> ALARMPLUGGEDON
|mutePluggedAlarm -> ALARMPLUGGEDMUTED
|reduceErrorPlugged -> ALARMPLUGGEDOFF
|turnOff -> ALARMPLUGGED
|emergencyTurnOff -> ALARMPLUGGED),

ALARMPLUGGEDMUTED = (
reduceErrorPlugged -> ALARMPLUGGEDOFF
|turnOff -> ALARMPLUGGED
|emergencyTurnOff -> ALARMPLUGGED).

//Assumption 3. Backup alarm is not related with power supply of the pump. 

BACKUPALARM = BACKUPALARMOFF,

BACKUPALARMOFF = (
emergencyTurnOff -> BACKUPALARMON
|powerErrorFixed -> BACKUPALARMOFF
),

BACKUPALARMON = (
backupAlarm -> BACKUPALARMON
|powerErrorFixed -> BACKUPALARMOFF
).



const MaxFluid = 10
range Volume = 0..MaxFluid

//Rate set
const LineOff = -1 //pump is off
const NotSet = 0
const MinRate = 1
const MaxRate = 2
range Rate = LineOff..MaxRate

//Assumption 4. If rate equals 2 and volume equals 1. Medicine would not be dispensed.
//Assumption 5. If line has 2 problems(e.g. pinched and unplugged) then when pinched error would be resolved line would identify unplugged error. 
//We assume that this consequence of steps would flow automatically.

LINE = L[MaxFluid][LineOff],
L[f:Volume][r:Rate] = (
refill -> L[MaxFluid][r]
|when (r == -1) turnOn -> L[f][NotSet] 
|when (f > r-1 && r > 0) dispense -> L[f-r][r]
|when (f < r) medicineEnded -> refillAfterError -> L[MaxFluid][r] //поставить приоритет этого действия
|refill-> L[MaxFluid][r] //refill2 - because it should be different with refill, because refill is concurrent with reduce from LOUDALARM
|when (r > 0) pinched -> unpinched -> L[f][r]
|when (r > 0) plugged -> unplugged -> L[f][r]
|when (r > -1) turnOff -> L[f][LineOff]
|when (r > -1) emergencyTurnOff -> L[f][LineOff]
|when (r > -1) emergencyTurnOff -> L[f][LineOff]
|when (r > 0) stopDispense -> L[f][NotSet] 
|when (r > -1) setRate[rNew:MinRate..MaxRate] -> L[f][rNew] 
).
||PUMP = (POWERSUPPLY || line[1..2]:LINE || line[1..2]:ALARMMEDICINE || line[1..2]:ALARMPINCHED || line[1..2]:ALARMPLUGGED 
 || line[1..2]:SAFE_DISPENSE || BACKUPALARM)  
/{forall[i:LinesRange]  
{
turnOn/line[i].turnOn,
turnOff/line[i].turnOff,
emergencyTurnOff/line[i].emergencyTurnOff,
emergencyTurnOff/line[i].emergencyTurnOff,
line[i].medicineEnded/line[i].errorMedicine,
line[i].refillAfterError/line[i].reduceErrorMedicine,
line[i].pinched/line[i].errorPinched,
line[i].unpinched/line[i].reduceErrorPinched,
line[i].plugged/line[i].errorPlugged,
line[i].unplugged/line[i].reduceErrorPlugged,
plugIn/powerErrorFixed,
changeBattery/powerErrorFixed
}}.

//Artur
//1.The pump cannot start pumping without the operator first confirming the settings on the pump.

//Artur
//2.Electrical power can fail at any time.

//Nikita
//3.If the backup battery power fails, pumping will not occur on any line.
fluent DISCHARGED = <plugOffToEmptyBattery, {chargeBattery, plugIn}>
assert NODISPENSE = [](DISCHARGED -> !line[i:RangeLine].dispense)

//Nikita
//4.It is always possible to resume pumping after a failure.
fluent MEDICINE_ENDED[i:RangeLine] = <line[i].medicineEnded, line[i].refillAfterError>
fluent PINCHED[i:RangeLine] = <line[i].pinched, line[i].unpinched>
fluent PLUGGED[i:RangeLine] = <line[i].plugged, line[i].unplugged>
assert RESUMEDISPENCE = [](forall[i:RangeLine](MEDICINE_ENDED[i] || PINCHED[i] || PLUGGED[i] -> <>line[i].dispence))

//Aleksandr
//5.An alarm will sound on any line failure (blockage, pinching, empty fluid, or
//whatever failures you model)
assert FAILURE_ALARM = [](forall[i:RangeLine](MEDICINE_ENDED[i] || PINCHED[i] || PLUGGED[i] -> <>HZ))

//Aleksandr
//6. In the absence of errors the pump will continue to pump until the
// treatment is finished.
assert PUMPING_MEDICINE = [](forall[i:RangeLine] ((!DISCHARGED && !PINCHED[i] && !PLUGGED[i] -> <>line[i].dispense) U MEDICINE_ENDED[i]))

//7.Artem. The system never deadlocks.(done)

//8.Artur. (two properties)
// The main action, dispense, may be made infinitely often (there is no irreversible problems)
assert INFINITE_DISPENSE = []<> line[i:RangeLine].dispense


// If rate was set before medicine in a line ended, the line can continue dispense after refilling 
fluent ENOUGH_MEDICINE[i:RangeLine] = <{line[i].refillAfterError, line[i].refill}, line[i].medicineEnded>
assert CONTINUE_DISPENSING = forall[i:RangeLine] [] ((SETTINGS_ARE_SET[i] && ENOUGH_MEDICINE[i]) -> <> line[i].dispense)

